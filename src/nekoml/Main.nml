/*
 *  NekoML Compiler
 *  Copyright (c)2005 Nicolas Cannasse
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

open Nekoml.Typer;

function complete(s) {
	var l = String.length s;
	if l > 0 && String.get s (l - 1) != '\\' && String.get s (l-1) != '/' then
		s + "/"
	else
		s
}

function report(msg,p) {
	if p == Lexer.null_pos then {
		Stack.dump IO.stderr Stack.exc();
		IO.printf IO.stderr "Exception : %s\n" msg
	} else
		IO.printf IO.stderr "%s(%d): %s\n" (Lexer.source p,Lexer.line p,msg);
	Sys.exit(-1);
}

try {
	var head = "NekoML v1.0 - (c)2005 Nicolas Cannasse\n Usage : nekoml [options] files...";
	var path = &["";"core/"];
	var files = &[];
	var decl = [
		("-p", Args.String (function(p) { path := complete p :: *path }) , "<path> : additional file search path");
		("-v", Args.Void (function() { verbose := true }) , ": verbose mode");
	];
	Args.parse head decl (function(f) { files := f :: *files });
	var ctx = context (*path);
	List.iter (function(file) {
		if *verbose then printf "Compiling %s\n" file;
		var modname = String.split (Sys.without_extension file) "/";
		ignore(load_module ctx modname Lexer.null_pos);
	}) (List.rev (*files));
	Hashtbl.iter (function(m,(e,deps,idents)) {
		var file = Nekoml.Type.file_name m ".neko";
		if *verbose then printf "Generating %s\n" file;
		var e = Nekoml.Neko.generate ctx e deps idents m;
		var ch = IO.write_file file false;
		var ctx = Neko.Printer.create ch;
		Neko.Printer.print ctx e;
		IO.close_out ch
	}) (modules ctx)
} catch {
	| Neko.Lexer.Error (msg,p) -> report Neko.Lexer.error_msg(msg) p
	| Neko.Parser.Error (msg,p) -> report Neko.Parser.error_msg(msg) p
	| Nekoml.Lexer.Error (msg,p) -> report Nekoml.Lexer.error_msg(msg) p
	| Nekoml.Parser.Error (msg,p) -> report Nekoml.Parser.error_msg(msg) p
	| Nekoml.Typer.Error (msg,p) -> report Nekoml.Typer.error_msg(msg) p
	| e -> report string(e) Lexer.null_pos
}
