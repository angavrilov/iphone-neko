type pos {
	psource : string;
	pline : int;
	pmin : int;
	pmax : int;	
}

type 'a t {
	mutable data : 'a;
	mutable current : string;
	buffer : string;
	mutable bin : int;
	mutable bpos : int;	
	mutable cin : int;
	mutable cpos : int;
	mutable input : IO.input;
	mutable source : string;
	mutable line : int;
	mutable pos : int;
	mutable carriage : bool;
}

type ('a,'b) tables {
	engine : LexEngine.tables;
	cases : ('b t -> 'a) array;
	def :  'b t -> 'a;
}

exception Invalid_rule : string

var bufsize = 4096
var null_pos = { pmin = -1; pmax = -1; pline = -1; psource = "<null>" };

function punion(p,p2) {
	{
		psource = p.psource;
		pline = p.pline;
		pmin = min p.pmin p2.pmin;
		pmax = max p.pmax p2.pmax;
	}
}

function create(data) {
	{
		data = data;
		carriage = false;
		current = "";
		buffer = String.create bufsize;
		bin = 0;
		bpos = 0;
		cin = 0;
		cpos = 0;
		input = IO.read_string "";
		source = "<null>";
		line = 0;
		pos = 0;
	}
}

function data(l) {
	l.data;
}

function set(l,data) {
	l.data := data;
}

function input(l,source,input,line,pos) {
	l.bin := 0;
	l.bpos := 0;
	l.cin := 0;
	l.cpos := 0;
	l.input := input;
	l.source := source;
	l.line := line;
	l.pos := pos;
}


function curpos(l) {
	var p = l.bpos + l.pos;
	{
		psource = l.source;
		pline = l.line;
		pmin = p - max 1 (String.length l.current);
		pmax = p - 1;
	}
}

function current(l) : string {
	l.current
}

function read(l) : char {
	if l.bin == 0 then {
		var delta = l.bpos - l.cpos;
		String.blit l.buffer 0 l.buffer l.cpos delta;
		var k = IO.input l.input l.buffer delta (bufsize - delta);		
		l.bpos := delta;
		l.cpos := 0;
		l.bin := l.bin + k;
		l.cin := l.cin + k;
	};
	var c = String.get l.buffer l.bpos;
	l.bpos := l.bpos + 1;
	l.bin := l.bin - 1;
	c
}

function inc_line(l,c) {
	if c == '\r' then
		l.carriage := true
	else if c == '\n' || l.carriage then {
		l.carriage := false;
		l.line := l.line + 1;
	};
}

function char(l) : char option {
	try {
		var c = read l;
		l.bpos := l.bpos - 1;
		l.bin := l.bin + 1;
		inc_line l c;
		Some c
	} catch {
		IO.Eof -> None
	}
}

function token(l,t) : 'a {
	var tbl = fst t.engine;
	var exits = snd t.engine;
	function rec loop(n,k) {
		var res = neko("tbl[0][k][0][read(l)]");
		if res == -1 then
			(n , exits.[k])
		else {
			match loop (n+1) res {
			| (_,-1) -> (n , exits.[k])
			| e -> e
			}
		}	
	};	
	var k = try {
		var n , k = loop 0 0;
		l.cin := l.cin - n;
		l.bin := l.cin;
		l.current := String.sub l.buffer l.cpos n;
		l.cpos := l.cpos + n;
		l.bpos := l.cpos;
		var i = &0;
		while *i < n {
			inc_line l (String.get l.current (*i));
			i := *i + 1;
		}
		k
	} catch {
		IO.Eof ->
			l.current := "";
			-1
	};
	if k == -1 then
		t.def(l)
	else
		t.cases.[k](l)
}

function build(rules,def) {
	var nfa = List.map (function((r,_)) { try LexEngine.parse r catch { _ -> throw Invalid_rule(r) } }) rules;
	var cases = List.array (List.map snd rules);
	{
		engine = LexEngine.make_tables (LexEngine.determinize (List.array nfa));
		cases = cases;
		def = def;
	}
}

function empty() {
	function empty_table(_) { invalid_arg() };
	build [] empty_table;
}
