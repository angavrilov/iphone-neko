
	<h1>Thread</h1>
	<p>
	An API to create and manager system threads and locks.
	</p>
	
<doc_blk>
  <doc_type>'thread</doc_type> <doc_name>thread_create</doc_name><doc_type>(f : function:1, p : any)</doc_type> <doc_doc>Creates a thread that will be running the function <doc_code>f(p)</doc_code></doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>'thread</doc_type> <doc_name>thread_current</doc_name><doc_type>()</doc_type> <doc_doc>Returns the current thread</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>thread_send</doc_name><doc_type>('thread, msg : any)</doc_type> <doc_doc>Send a message into the target thread message queue</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>any</doc_type> <doc_name>thread_read_message</doc_name><doc_type>(block : bool)</doc_type> <doc_doc>
	Reads a message from the message queue. If <doc_code>block</doc_code> is true, the
	function only returns when a message is available. If <doc_code>block</doc_code> is
	false and no message is available in the queue, the function will
	return immediatly <doc_code>null</doc_code>.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>'lock</doc_type> <doc_name>lock_create</doc_name><doc_type>()</doc_type> <doc_doc>Creates a lock which is initially locked</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>lock_release</doc_name><doc_type>('lock)</doc_type> <doc_doc>
	Release a lock. The thread does not need to own the lock to be
	able to release it. If a lock is released several times, it can be
	acquired as many times
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>bool</doc_type> <doc_name>lock_wait</doc_name><doc_type>('lock, timeout : number?)</doc_type> <doc_doc>
	Waits for a lock to be released and acquire it.
	If <doc_code>timeout</doc_code> (in seconds) is not null and expires then
	the returned value is false
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>'tls</doc_type> <doc_name>tls_create</doc_name><doc_type>()</doc_type> <doc_doc>
	Creates thread local storage. This is placeholder that can store a value that will
	be different depending on the local thread. You must set the tls value to <doc_code>null</doc_code>
	before exiting the thread or the memory will never be collected.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>any</doc_type> <doc_name>tls_get</doc_name><doc_type>('tls)</doc_type> <doc_doc>
	Returns the value set by <doc_code>tls_set</doc_code> for the local thread.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>tls_set</doc_name><doc_type>('tls, any)</doc_type> <doc_doc>
	Set the value of the TLS for the local thread.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>'mutex</doc_type> <doc_name>mutex_create</doc_name><doc_type>()</doc_type> <doc_doc>
	Creates a mutex, which can be used to acquire a temporary lock to access some ressource.
	The main difference with a lock is that a mutex must always be released by the owner thread.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>mutex_acquire</doc_name><doc_type>('mutex)</doc_type> <doc_doc>
	The current thread acquire the mutex or wait if not available. The same thread can acquire
	several times the same mutex but must release it as many times it has been acquired.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>bool</doc_type> <doc_name>mutex_try</doc_name><doc_type>('mutex)</doc_type> <doc_doc>
	Try to acquire the mutex, returns true if acquire or false if it's already locked by another
	thread.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>mutex_release</doc_name><doc_type>('mutex)</doc_type> <doc_doc>
	Release a mutex that has been acquired by the current thread. The behavior is undefined if the
	current thread does not own the mutex.
	</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>'deque</doc_type> <doc_name>deque_create</doc_name><doc_type>()</doc_type> <doc_doc>create a message queue for multithread access</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>deque_add</doc_name><doc_type>('deque, any)</doc_type> <doc_doc>add a message at the end of the queue</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>void</doc_type> <doc_name>deque_push</doc_name><doc_type>('deque, any)</doc_type> <doc_doc>add a message at the head of the queue</doc_doc>
</doc_blk>
<doc_blk>
  <doc_type>any?</doc_type> <doc_name>deque_pop</doc_name><doc_type>('deque, bool)</doc_type> <doc_doc>pop a message from the queue head. Either block until a message is available or return immedialtly with null.</doc_doc>
</doc_blk>
