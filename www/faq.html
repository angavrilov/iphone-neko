<h1>FAQ</h1>

<p>
	Frequently Asked Questions about Neko :
</p>

<ul>
	<li><a href="#jvm">How is Neko different from DotNet / JVM ?</a></li>
	<li><a href="#llvm">How is Neko different from LLVM / C-- ?</a></li>
	<li><a href="#php">How is Neko different from PHP / Perl / Python / Ruby / Lua ?</a></li>
	<li><a href="#parrot">How is Neko different from Parrot ?</a></li>
	<li><a href="#gc">What garbage collector is Neko using ?</a></li>
	<li><a href="#arch">On which architecture can Neko run ?</a></li>
	<li><a href="#more">More questions ?</a></li>
</ul>

<a name="jvm"></a>
<h2>How is Neko different from (CLR) DotNet / JVM ?</h2>

<p>
	The CLR and the Java Virtual Machine are both defined by a <em>bytecode</em> language with a <em>static type system</em> based on <em>classes</em>. As a result, you can easily run languages that have a type system compatible with Java or C# on theses virtual machines. But if you have a dynamicly typed language or no class system, you'll have to trick the virtual machine and find a <em>type mapping</em> from your type system to the JVM or DotNet one.
</p>

<p>
	Neko is a lot more simple. First it is not a <em>bytecode</em> language but a high-level <em>programming</em> language. You don't have then to write a <em>compiler</em> for it, a simple <em>generator</em> that translates your program into the corresponding Neko program is enough. You still have to find a mapping from your values to Neko <em>data structures</em> but Neko gives you a dynamicly typed language with no fixed class system. You have then to find a <em>runtime mapping</em> so that your program <em>executes</em> correctly on Neko, and not a <em>type mapping</em> so that your program <em>types</em> correcty like with DotNet / JVM.
</p>

<p>
	As a result, it is easier to add a new or existing language for the NekoVM than it is for the CLR / JVM, since you don't have to deal with a highlevel type system. Also, it means that languages can interoperate more easily since they only need to share the same <em>data structures</em> and not always the type <em>types</em>.
</p>

<a name="llvm"></a>
<h2>How is Neko different from LLVM / C-- ?</h2>

<p>
	Theses are compiler frameworks with low level <em>abstract processor instructions</em> and a  static type system with low level <em>memory manipulation functions</em>. It would be possible for example to uses theses frameworks to compile Neko, which stands as an higher level language, although Neko is powered by its own runtime.
</p>

<p>
	As a result, Neko is maybe less optimizable than theses <em>abstract processors</em> but is a lot more easy to target for language designers that want to reuse a runtime. Since Neko is not a <em>framework</em> either, it is very lightweight. For example you only need <code>libneko.so</code> which is only 68 KB in order to embed an run Neko programs in your application.
</p>

<a name="php"></a>
<h2>How is Neko different from PHP / Perl / Python / Ruby / Lua ?</h2>

<p>
	Theses languages are meant to be programmed. They contain sometimes complex but powerful features. But often, their runtimes are entirely written in C, difficult to maintain, and their interpreters are quite slow. Neko runtime could be used to run theses languages more efficiently, and help them interact together and share the same libraries.
</p>

<p>
	It is actually one of the goals of Neko to be able to run these languages on the same runtime. Since they're currently either interpreted or running in a not-so-fast virtual machine, using an intermediate compilable representation such as Neko should be a pretty good improvment, especialy when JIT will be added.
</p>

<a name="parrot"></a>
<h2>How is Neko different from Parrot ?</h2>

<p>
	Targeting Parrot is quite complex, with different languages at different levels (low level PASM and medium level PIR). In particular, it is difficult to differenciate beetween the <em>language</em> and the <em>libraries</em>. Also, it gives access to more <em>low level</em> bytecode which make it difficult to change it later without breaking backward compatibility. OTOH Neko compiler is handling the lowlevel and the Neko language is as much abstract as possible.
</p>

<p>
	Parrot is written in C while Neko compiler is written... in Neko. The language is fully bootstrapped right now. Also, Neko is lightweight and the Virtual Machine is only 68 KB on Linux and 40 KB on Windows, while still offering a very good speed.
</p>

<a name="gc"></a>
<h2>What garbage collector is Neko using ?</h2>

<p>
	Neko is using the <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm GC</a> which is a conservative multithreaded mark and sweep collector. However since all calls to the GC are wrapper by the Neko API in <code>vm/alloc.c</code> it might be possible in the future to switch easily to another garbage collector.
</p>

<a name="arch"></a>
<h2>On which architecture can Neko run ?</h2>

<p>
	Neko is known to run on Windows x86, Linux, BSD, OSX, and Linux AMD64 architectures. A lot more architectures should be easily targeted since the NekoVM is written in pure ANSI C with only some differences for specific things such as some standard library functions for system API and dynamic loading.
</p>

<a name="more"></a>
<h2>More questions ?</h2>

<p>
	You can ask on the <a href="/?doc=doc">mailing list</a>.
</p>
