/*
 *  Neko Compiler
 *  Copyright (c)2005 Nicolas Cannasse
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

open Ast;
open Bytecode;

type label {
	lname : string;
	ltraps : int;
	lstack : int;
	mutable lpos : int option;
	mutable lwait : (void -> void) list;
}

type context {
	mutable ops : opcode array;
	mutable locals : (string,int) Map.t;
	globals : (global,int) Hashtbl.t;
	gobjects : (string list,int) Hashtbl.t;
	mutable env : (string,int) Map.t;
	mutable nenv : int;
	mutable stack : int;
	mutable loop_limit : int;
	mutable limit : int;
	mutable ntraps : int;
	mutable breaks : (void -> void, pos) list;
	mutable continues : (void -> void, pos) list;
	mutable functions : (opcode array, int , int) list;
	mutable gtable : global array;
	labels : (string,label) Hashtbl.t;
}

type error_msg = string

exception Error : (error_msg , pos)

function error(e,p) {
	throw Error(e,p)
}

function error_msg(s) {
	s
}

function stack_delta(o) {
	match o {
	| AccNull
	| AccTrue
	| AccFalse
	| AccThis
	| AccInt _
	| AccStack _
	| AccGlobal _
	| AccEnv _
	| AccField _
	| AccBuiltin _
	| AccIndex _
	| JumpIf _
	| JumpIfNot _
	| Jump _
	| Ret _
	| SetGlobal _
	| SetStack _
	| SetEnv _
	| SetThis
	| Bool
	| EndTrap
	| IsNull
	| IsNotNull
	| Not
	| Hash
	| TypeOf
	| New
		-> 0
	| Add
	| Sub
	| Mult
	| Div
	| Mod
	| Shl
	| Shr
	| UShr
	| Or
	| And
	| Xor
	| Eq
	| Neq
	| Gt
	| Gte
	| Lt
	| Lte
		-> -1
	| AccArray -> -1
	| SetField _ | SetIndex _ | Compare -> -1
	| SetArray -> -2
	| Push -> 1
	| Pop x -> -x
	| Call nargs -> -nargs
	| ObjCall nargs -> -(nargs + 1)
	| MakeEnv size | MakeArray size -> -size
	| Trap _ -> trap_stack_delta
	}
}

function pos(ctx) {
	Array.length ctx.ops
}

function write(ctx,op) {
	ctx.stack := ctx.stack + stack_delta op;
	Array.add ctx.ops op
}

function jmp(ctx) {
	var p = pos ctx;
	write ctx (Jump 0);
	function() {
		Array.set ctx.ops p Jump(pos ctx - p)
	}
}

function cjmp(cond,ctx) {
	var p = pos ctx;
	write ctx (Jump 0);
	function() {
		Array.set ctx.ops p (if cond then JumpIf else JumpIfNot)(pos ctx - p)
	}
}

function goto(ctx,p) {
	write ctx Jump(p - pos ctx)
}

function global(ctx,g) {
	try
		Hashtbl.find ctx.globals g
	catch {
		Not_found ->
			var gid = Array.length ctx.gtable;
			Hashtbl.add ctx.globals g gid;
			Array.add ctx.gtable g;
			gid
	}
}

function save_breaks(ctx) {
	var oldc = ctx.continues;
	var oldb = ctx.breaks;
	var oldl = ctx.loop_limit;
	ctx.loop_limit := ctx.stack;
	ctx.breaks := [];
	ctx.continues := [];
	(ctx , oldc, oldb , oldl)
}

function process_continues((ctx,oldc,_,_)) {
	List.iter (function((f,_)) { f() }) ctx.continues;
	ctx.continues := oldc
}

function process_breaks((ctx,_,oldb,oldl)) {
	List.iter (function((f,_)) { f() }) ctx.breaks;
	ctx.loop_limit := oldl;
	ctx.breaks := oldb
}

function check_breaks(ctx) {
	List.iter (function((_,p)) { error "Break outside a loop" p }) ctx.breaks;
	List.iter (function((_,p)) { error "Continue outside a loop" p }) ctx.continues
}

function rec scan_labels(ctx,supported,e) {
	match fst e {
	| EFunction (args,e) ->
		var nargs = List.length args;
		var ntraps = ctx.ntraps;
		ctx.ntraps := 0;
		ctx.stack := ctx.stack + nargs;
		scan_labels ctx supported e;
		ctx.stack := ctx.stack - nargs;
		ctx.ntraps := ntraps
	| EBlock _ ->
		var old = ctx.stack;
		Ast.iter (scan_labels ctx supported) e;
		ctx.stack := old
	| EVars l ->
		List.iter (function((_,e)) {
			match e {
			| None -> ()
			| Some e -> scan_labels ctx supported e
			};
			ctx.stack := ctx.stack + 1
		}) l
	| ELabel l when !supported ->
		error "Label is not supported in this part of the program" (snd e);
	| ELabel l when Hashtbl.exists ctx.labels l ->
		error ("Duplicate label " + l) (snd e)
	| ELabel l ->
		var label = {
			lname = l;
			ltraps = ctx.ntraps;
			lstack = ctx.stack;
			lpos = None;
			lwait = [];
		};
		Hashtbl.add ctx.labels l label
	| ETry (e,_,e2) ->
		ctx.stack := ctx.stack + trap_stack_delta;
		ctx.ntraps := ctx.ntraps + 1;
		scan_labels ctx supported e;
		ctx.stack := ctx.stack - trap_stack_delta;
		ctx.ntraps := ctx.ntraps - 1;
		ctx.stack := ctx.stack + 1;
		scan_labels ctx supported e2;
		ctx.stack := ctx.stack - 1;
	| EBinop ("=",e1,e2) ->
		function rec is_extended((e,_)) {
			match e {
			| EParenthesis e -> is_extended e
			| EArray _
			| EField _ ->
				true
			| _ ->
				false
			}
		};
		var ext = is_extended e1;
		if ext then ctx.stack := ctx.stack + 1;
		scan_labels ctx supported e2;
		ctx.stack := ctx.stack + 1;
		scan_labels ctx supported e1;
		ctx.stack := ctx.stack - (if ext then 2 else 1);
	| ECall ((EConst (Builtin x),_),el) when x != "array" && x != "apply" ->
		Ast.iter (scan_labels ctx false) e
	| ECall(_,el) ->
		List.iter (function(e) {
			scan_labels ctx supported e;
			ctx.stack := ctx.stack + 1;
		}) el;
		ctx.stack := ctx.stack - List.length el
	| EObject fl ->
		ctx.stack := ctx.stack + 2;
		List.iter (function((s,e)) {
			scan_labels ctx supported e
		}) fl;
		ctx.stack := ctx.stack - 2;
	| EConst _
	| EContinue
	| EBreak _
	| EReturn _
	| EIf _
	| EWhile _
	| EParenthesis _
	| ENext _ ->
		Ast.iter (scan_labels ctx supported) e
	| EBinop (_,_,_)
	| EArray _
	| EField _ 
		->
		Ast.iter (scan_labels ctx false) e
	}
}

function compile_constant(ctx,c,p) {
	match c {
	| True -> write ctx AccTrue
	| False -> write ctx AccFalse
	| Null -> write ctx AccNull
	| This -> write ctx AccThis
	| Int n -> write ctx (AccInt n)
	| Float f -> write ctx (AccGlobal (global ctx (GlobalFloat f)))
	| String s -> write ctx (AccGlobal (global ctx (GlobalString s)))
	| Builtin s ->
		match s {
		| "tnull" -> write ctx (AccInt 0)
		| "tint" -> write ctx (AccInt 1)
		| "tfloat" -> write ctx (AccInt 2)
		| "tbool" -> write ctx (AccInt 3)
		| "tstring" -> write ctx (AccInt 4)
		| "tobject" -> write ctx (AccInt 5)
		| "tarray" -> write ctx (AccInt 6)
		| "tfunction" -> write ctx (AccInt 7)
		| "tabstract" -> write ctx (AccInt 8)
		| s ->
			write ctx (AccBuiltin s)
		}
	| Ident s ->
		try {
			var e = Map.find ctx.env s;
			write ctx (AccEnv e);
		} catch { Not_found -> try {
			var l = Map.find ctx.locals s;
			if l <= ctx.limit then {
				var e = ctx.nenv;
				ctx.nenv := ctx.nenv + 1;
				ctx.env := Map.add ctx.env s e;
				write ctx (AccEnv e);
			} else
				write ctx (AccStack (ctx.stack - l));
		} catch { Not_found ->
			var g = global ctx (GlobalVar s);
			write ctx (AccGlobal g)
		}}
	}
}

function rec compile_binop(ctx,op,e1,e2,p) {
	match op {
	| "=" ->
		match fst e1 {
		| EConst (Ident s) ->
			compile ctx e2;
			try {
				var e = Map.find ctx.env s;
				write ctx (SetEnv e);
			} catch { Not_found -> try {
				var l = Map.find ctx.locals s;
				if l <= ctx.limit then {
					var e = ctx.nenv;
					ctx.nenv := ctx.nenv + 1;
					ctx.env := Map.add ctx.env s e;
					write ctx (SetEnv e);
				} else
					write ctx (SetStack (ctx.stack - l))
			} catch { Not_found ->
				var g = global ctx (GlobalVar s);
				write ctx (SetGlobal g)
			}}
		| EField (e,f) ->
			compile ctx e;
			write ctx Push;
			compile ctx e2;
			write ctx (SetField f)
		| EArray (e1,(EConst (Int n),_)) ->
			compile ctx e1;
			write ctx Push;
			compile ctx e2;
			write ctx (SetIndex n)
		| EArray (ea,ei) ->
			compile ctx ei;
			write ctx Push;
			compile ctx ea;
			write ctx Push;
			compile ctx e2;
			write ctx SetArray
		| EConst This ->
			compile ctx e2;
			write ctx SetThis
		| _ ->
			error "Invalid assign" p
		}
	| "&&" ->
		compile ctx e1;
		var jnext = cjmp false ctx;
		compile ctx e2;
		jnext()
	| "||" ->
		compile ctx e1;
		var jnext = cjmp true ctx;
		compile ctx e2;
		jnext()
	| _ ->
		match (op , e1 , e2) {
		| ("==" , _ , (EConst Null,_)) ->
			compile ctx e1;
			write ctx IsNull
		| ("!=" , _ , (EConst Null,_)) ->
			compile ctx e1;
			write ctx IsNotNull
		| ("==" , (EConst Null,_) , _) ->
			compile ctx e2;
			write ctx IsNull
		| ("!=" , (EConst Null,_) , _) ->
			compile ctx e2;
			write ctx IsNotNull
		| _ ->
			compile ctx e1;
			write ctx Push;
			compile ctx e2;
			match op {
			| "+" -> write ctx Add
			| "-" -> write ctx Sub
			| "/" -> write ctx Div
			| "*" -> write ctx Mult
			| "%" -> write ctx Mod
			| "<<" -> write ctx Shl
			| ">>" -> write ctx Shr
			| ">>>" -> write ctx UShr
			| "|" -> write ctx Or
			| "&" -> write ctx And
			| "^" -> write ctx Xor
			| "==" -> write ctx Eq
			| "!=" -> write ctx Neq
			| ">" -> write ctx Gt
			| ">=" -> write ctx Gte
			| "<" -> write ctx Lt
			| "<=" -> write ctx Lte
			| _ -> error "Unknown operation" p
			}
		}
	}
}

function rec compile_function(ctx,params,e) {
	var limit = ctx.limit;
	var ops = ctx.ops;
	var breaks = ctx.breaks;
	var continues = ctx.continues;
	var locals = ctx.locals;
	var env = ctx.env;
	var nenv = ctx.nenv;
	var ntraps = ctx.ntraps;
	ctx.ops := Array.create();
	ctx.breaks := [];
	ctx.continues := [];
	ctx.env := Map.empty;
	ctx.nenv := 0;
	ctx.ntraps := 0;
	ctx.limit := ctx.stack;
	List.iter (function(v) {
		ctx.stack := ctx.stack + 1;
		ctx.locals := Map.add ctx.locals v ctx.stack;
	}) params;
	var s = ctx.stack;
	compile ctx e;
	write ctx (Ret (ctx.stack - ctx.limit));
	if ctx.stack != s then assert();
	check_breaks ctx;
	ctx.stack := ctx.limit;
	ctx.limit := limit;
	ctx.breaks := breaks;
	ctx.continues := continues;
	ctx.locals := locals;
	var gid = Array.length ctx.gtable;
	ctx.functions := (ctx.ops,gid,List.length params) :: ctx.functions;
	Array.add ctx.gtable GlobalFunction(gid,-1);
	ctx.ops := ops;
	var local_env = ctx.env;
	var local_nenv = ctx.nenv;
	ctx.env := env;
	ctx.ntraps := ntraps;
	ctx.nenv := nenv;
	if local_nenv > 0 then {
		var a = Array.make local_nenv "";
		Map.iter (function(v,i){ a.[i] := v }) local_env;
		Array.iter (function(v){
			compile_constant ctx (Ident v) Lexer.null_pos;
			write ctx Push;
		}) a;
		write ctx (AccGlobal gid);
		write ctx (MakeEnv local_nenv);
	} else
		write ctx (AccGlobal gid);
}

function rec compile_builtin(ctx,b,el,p) {
	match (b , el) {
	| ("istrue" , [e]) ->
		compile ctx e;
		write ctx Bool
	| ("not" , [e]) ->
		compile ctx e;
		write ctx Not
	| ("typeof" , [e]) ->
		compile ctx e;
		write ctx TypeOf
	| ("hash" , [e]) ->
		compile ctx e;
		write ctx Hash
	| ("compare" , [e1;e2]) ->
		compile ctx e1;
		write ctx Push;
		compile ctx e2;
		write ctx Compare
	| ("goto" , [(EConst (Ident l) , _)] ) ->
		var l = try Hashtbl.find ctx.labels l catch { Not_found -> error ("Unknown label " + l) p };
		var os = ctx.stack;
		var ntraps = &ctx.ntraps;
		var etraps = &[];
		while *ntraps > l.ltraps {
			write ctx EndTrap;
			ctx.stack := ctx.stack - trap_stack_delta;
			ntraps := *ntraps - 1;
		};
		while *ntraps < l.ltraps {
			etraps := (pos ctx) :: *etraps;
			write ctx (Trap 0);
			ntraps := *ntraps + 1;
		};
		if ctx.stack > l.lstack then write ctx (Pop (ctx.stack - l.lstack));
		while ctx.stack < l.lstack {
			write ctx Push;
		};
		ctx.stack := os;
		match l.lpos {
		| None -> l.lwait := jmp ctx :: l.lwait
		| Some p -> write ctx (Jump p)
		};
		if *etraps != [] then {
			List.iter (function(p) {
				Array.set ctx.ops p (Trap (pos ctx - p));
			}) (*etraps);
			write ctx Push;
			compile_constant ctx (Builtin "throw") p;
			write ctx (Call 1);
		}
	| ("goto" , _) ->
		error "Invalid $goto statement" p
	| _ ->
		List.iter (function(e) {
			compile ctx e;
			write ctx Push;
		}) el;
		compile_constant ctx (Builtin b) p;
		write ctx (Call (List.length el))
	}
}

function rec compile(ctx,(e,p)) {
	match e {
	| EConst c ->
		compile_constant ctx c p
	| EBlock [] ->
		write ctx AccNull
	| EBlock el ->
		var locals = ctx.locals;
		var stack = ctx.stack;
		List.iter (compile ctx) el;
		if stack < ctx.stack then write ctx (Pop (ctx.stack - stack));
		if stack != ctx.stack then assert();
		ctx.locals := locals
	| EParenthesis e ->
		compile ctx e
	| EField (e,f) ->
		compile ctx e;
		write ctx (AccField f)
	| ECall ((EConst (Builtin "array"),_),el) ->
		List.iter (function(e) {
			compile ctx e;
			write ctx Push;
		}) el;
		write ctx (MakeArray (List.length el));
	| ECall (_,el) when List.length el > max_call_args ->
		error "Too many arguments" p
	| ECall ((EField (e,f),_),el) ->
		List.iter (function(e) {
			compile ctx e;
			write ctx Push;
		}) el;
		compile ctx e;
		write ctx Push;
		write ctx (AccField f);
		write ctx (ObjCall (List.length el))
	| ECall ((EConst (Builtin b),_),el) ->
		compile_builtin ctx b el p
	| ECall (e,el) ->
		List.iter (function(e) {
			compile ctx e;
			write ctx Push;
		}) el;
		compile ctx e;
		write ctx (Call (List.length el))
	| EArray (e1,(EConst (Int n),_)) ->
		compile ctx e1;
		write ctx (AccIndex n)
	| EArray (e1,e2) ->
		compile ctx e1;
		write ctx Push;
		compile ctx e2;
		write ctx AccArray
	| EVars vl ->
		List.iter (function((v,o)) {
			match o {
			| None -> write ctx AccNull
			| Some e -> compile ctx e
			};
			write ctx Push;
			ctx.locals := Map.add ctx.locals v ctx.stack;
		}) vl
	| EWhile (econd,e,NormalWhile) ->
		var start = pos ctx;
		compile ctx econd;
		var jend = cjmp false ctx;
		var save = save_breaks ctx;
		compile ctx e;
		process_continues save;
		goto ctx start;
		process_breaks save;
		jend();
	| EWhile (econd,e,DoWhile) ->
		var start = pos ctx;
		var save = save_breaks ctx;
		compile ctx e;
		process_continues save;
		compile ctx econd;
		write ctx (JumpIf (start - pos ctx));
		process_breaks save
	| EIf (e,e1,e2) ->
		var stack = ctx.stack;
		compile ctx e;
		var jelse = cjmp false ctx;
		compile ctx e1;
		if stack != ctx.stack then assert();
		match e2 {
		| None ->
			jelse()
		| Some e2 ->
			var jend = jmp ctx;
			jelse();
			compile ctx e2;
			if stack != ctx.stack then assert();
			jend()
		};
	| ETry (e,v,ecatch) ->
		var start = pos ctx;
		write ctx (Trap 0);
		ctx.ntraps := ctx.ntraps + 1;
		compile ctx e;
		ctx.ntraps := ctx.ntraps - 1;
		ctx.stack := ctx.stack - trap_stack_delta;
		write ctx EndTrap;
		var jend = jmp ctx;
		Array.set ctx.ops start (Trap (pos ctx - start));
		write ctx Push;
		var locals = ctx.locals;
		ctx.locals := Map.add ctx.locals v ctx.stack;
		compile ctx ecatch;
		write ctx (Pop 1);
		ctx.locals := locals;
		jend()
	| EBinop ("-",(EConst (Int 0),_),(EConst (Int i),_)) ->
		compile ctx (EConst (Int (-i)),p)
	| EBinop (op,e1,e2) ->
		compile_binop ctx op e1 e2 p
	| EReturn None ->
		write ctx AccNull;
		var i = &0;
		while *i < ctx.ntraps {
			write ctx EndTrap;
			i := *i + 1;
		}
		write ctx (Ret (ctx.stack - ctx.limit));
	| EReturn (Some e) ->
		compile ctx e;
		var i = &0;
		while *i < ctx.ntraps {
			write ctx EndTrap;
			i := *i + 1;
		}
		write ctx (Ret (ctx.stack - ctx.limit - ctx.ntraps * trap_stack_delta));
	| EBreak e ->
		if ctx.ntraps == 0 then assert();
		match e {
		| None -> ()
		| Some e -> compile ctx e
		};
		if ctx.loop_limit != ctx.stack then Array.add ctx.ops (Pop (ctx.stack - ctx.loop_limit));
		ctx.breaks := (jmp ctx , p) :: ctx.breaks
	| EContinue ->
		if ctx.ntraps == 0 then assert();
		if ctx.loop_limit != ctx.stack then Array.add ctx.ops (Pop (ctx.stack - ctx.loop_limit));
		ctx.continues := (jmp ctx , p) :: ctx.continues
	| EFunction (params,e) ->
		compile_function ctx params e
	| ENext (e1,e2) ->
		compile ctx e1;
		compile ctx e2
	| EObject [] ->
		write ctx AccNull;
		write ctx New
	| EObject fl ->
		var fields = List.sort compare (List.map fst fl);
		var id = try
			Hashtbl.find ctx.gobjects fields
		catch { Not_found ->
			var id = global ctx (GlobalVar ("o:" + Hashtbl.length ctx.gobjects));
			Hashtbl.add ctx.gobjects fields id;
			id
		};
		write ctx (AccGlobal id);
		write ctx New;
		write ctx Push;
		List.iter (function((f,e)) {
			write ctx Push;
			compile ctx e;
			write ctx (SetField f);
			write ctx (AccStack 0);
		}) fl;
		write ctx (Pop 1)
	| ELabel l ->
		var l = try Hashtbl.find ctx.labels l catch { Not_found -> assert() };
		if ctx.stack != l.lstack then assert();
		if ctx.ntraps != l.ltraps then assert();
		List.iter (function(f) { f() }) l.lwait;
		l.lwait := [];
		l.lpos := Some (pos ctx)
	}
}

function compile(ast) {
	var ctx = {
		stack = 0;
		loop_limit = 0;
		limit = -1;
		globals = Hashtbl.create();
		gobjects = Hashtbl.create();
		gtable = Array.create();
		locals = Map.empty;
		ops = Array.create();
		breaks = [];
		continues = [];
		functions = [];
		env = Map.empty;
		nenv = 0;
		ntraps = 0;
		labels = Hashtbl.create();
	};
	scan_labels ctx true ast;
	compile ctx ast;
	check_breaks ctx;
	if ctx.functions != [] || Hashtbl.length ctx.gobjects != 0 then {
		var ctxops = ctx.ops;
		var ops = Array.create();
		ctx.ops := ops;
		write ctx (Jump 0);
		List.iter (function((fops,gid,nargs)) {
			Array.set ctx.gtable gid GlobalFunction(Array.length ops,nargs);
			Array.append fops ops;
		}) (List.rev ctx.functions);
		Array.set ops 0 (Jump (Array.length ops));
		Hashtbl.iter (function(fl,g) {
			write ctx AccNull;
			write ctx New;
			write ctx (SetGlobal g);
			List.iter (function(f) {
				write ctx (AccGlobal g);
				write ctx Push;
				write ctx (SetField f);
			}) fl
		}) ctx.gobjects;
		Array.append ctxops ops;
	};
	(ctx.gtable, ctx.ops)
}
